/**
 * Rich HTML code component.
 * 
 * (c) Thassilo Martin Schiepanski
 */

"use strict"; (_ => { window.HTMLCodeComponent = (_ => { const devConfig = { languageWildcard: "*", observedAttributes: [ "copyable", "editable", "highlight", "language", "type-live" ], tagName: "code-component", templateIdentifierAttribute: "code-component--template" }; const objPrivateMap = new WeakMap(); let customConfig = { "tab-size": 4, "copyable": false, "editable": false, "language": null, "type-live": 1, "no-overflow": false }; function setObjPrivate(objRef, key, value) { const map = objPrivateMap.get(objRef) ?? new Map(); map.set(key, value); objPrivateMap.set(objRef, map); } function getObjPrivate(objRef, key) { const map = objPrivateMap.get(objRef); return map ? map.get(key) : undefined; } function createTab(character) { return Array.from({ length: customConfig["tab-size"] }, _ => character).join(""); } function _update(objRef, code) { ![undefined, null].includes(objRef.typeLive) ? _applyLiveTyping(objRef, code) : _applyFormatHandler(objRef, code); } function _deleteRequiredCssRule(objRef, index) { const host = getObjPrivate(objRef, "host"); host .styleSheets[host.styleSheets.length - 1] .deleteRule(index); } function _readBareContent(objRef, noUnicode = false) { const host = getObjPrivate(objRef, "host"); if(!host) return ""; const bare = host.querySelector(".edit-in").textContent; return noUnicode ? bare.replace(/\u2003|\u200b/g, " ") : bare; } function _applyFormatHandler(objRef, input) { const language = objRef.language || customConfig["language"]; const handlers = (formatHandlers.get(devConfig.languageWildcard) || []) .concat(formatHandlers.get(language) || []); const tagRegex = /<( *(\/ *)?(?!br)[a-z][a-z0-9_-]*( +[a-z0-9_-]+ *(= *("|')((?!\\\6)(.| ))*\6)?)* *)>/gi; input = input ?? _readBareContent(objRef); let output = input; if(handlers.length) { handlers.forEach(handler => { output = handler(output, language); }); } else { output = output.replace(tagRegex, "&lt;$1&gt;") } const openingTags = []; const host = getObjPrivate(objRef, "host"); host.querySelector(".edit-out").innerHTML = output .split(/\n/g) .map(line => { const prevOpeningTags = Object.assign([], openingTags); let index = 0; (line.match(tagRegex) || []) .forEach(tag => { const tagName = tag.match(/[a-z][a-z0-9_-]*/i)[0]; if(/^< *\//.test(tag)) { while(![tagName, undefined].includes(openingTags.pop())); return; } openingTags.push({ name: tagName, tag: tag }); const prevIndex = index; index = index + tag.length; line = `${line.slice(0, prevIndex)}${ line.slice(prevIndex, index) .replace(/(^| )([^ ]+)/g, `${"$1".replace(/ /, "\u2003")}<span>$2</span>`) }${line.slice(index)}`; }); return `<div>${ prevOpeningTags .map(tag => { return tag.tag }) .join("") }${line}${ openingTags .map(tag => { return `</${tag.name}>`; }) .join("") }</div>`; }) .join(""); const lineNumbers = []; let lineHeight; Array.from(host.querySelector(".edit-out").querySelectorAll("div")) .forEach(div => { const computedStyle = window.getComputedStyle(div); lineHeight = lineHeight || parseInt(computedStyle.getPropertyValue("line-height")); const ratio = customConfig["no-overflow"] ? Math.round(parseInt(computedStyle.getPropertyValue("height")) / lineHeight) : 1; lineNumbers.push(`${lineNumbers.length + 1}${Array.from({ length: ratio }, _ => "<br>").join("")}`); }); host.querySelector(".lines").innerHTML = lineNumbers.join(""); _applyHighlighting(this); } function _applyCopyHandler(objRef) { const host = getObjPrivate(objRef, "host"); const copyButton = host.querySelector(".copy"); try { navigator.clipboard.writeText(objRef.textContent); copyHandler && copyHandler(copyButton); } catch(err) { copyHandler && copyHandler(copyButton); } } function _applyHighlighting(objRef) { const host = getObjPrivate(objRef, "host"); if(!host) return; const lineDivs = Array.from(host.querySelectorAll(".edit-out > div")); lineDivs.forEach(div => div.classList.remove("highlighted")); if(!objRef.highlight) return; objRef.highlight .split(/[;,]/g) .map(instruction => instruction.trim()) .forEach(instruction => { if(/^[0-9]+$/.test(instruction)) { lineDivs[parseInt(instruction) - 1] && lineDivs[parseInt(instruction) - 1].classList.add("highlighted"); return; } if(!/^[0-9]+ *- *[0-9]+$/.test(instruction)) { return; } const indices = instruction .split("-") .map(index => parseInt(index.trim())) .sort(); for(let index = indices[0]; index <= indices[1]; index++) { if(!lineDivs[parseInt(index) - 1]) { return; } lineDivs[parseInt(index) - 1].classList.add("highlighted"); } }); } function _applyLiveTyping(objRef, input) { if(getObjPrivate(objRef, "isLiveTyping")) return; setObjPrivate(objRef, "isLiveTyping", true); const speed = parseFloat(objRef.typeLive) || customConfig["type-live"]; const remainingInput = Array.from({ length: 5 }, _ => "") .concat((input || _readBareContent(objRef)).split("")); const writtenInput = []; const whitespaceRegex = /^(\s|\n)$/; let lastChar = " "; const type = fixedDelay => { const curChar = remainingInput.shift(); writtenInput.push(curChar); const delayBounds = (whitespaceRegex.test(lastChar)) ? (/\s|\n/.test(curChar) ? [ 50, 250 ] : [ 300, 750 ]) : [25, 300]; const delay = fixedDelay || Math.round(((Math.random() * (delayBounds[1] - delayBounds[0])) + delayBounds[0]) * (speed || 1)); lastChar = curChar; const curCode = writtenInput.join(""); _applyFormatHandler(objRef, `${ curCode }${ (remainingInput.join("").match(/\n/g) ?? []) .join("") }`); setTimeout(_ => { (remainingInput.length > 0) ? type() : setObjPrivate(objRef, "isLiveTyping", false); }, delay); }; type(0); } function _getBinaryAttribute(objRef, attribute) { const value = objRef.getAttribute(attribute); return ![undefined, null, "false"].includes(value); } function _setAttribute(objRef, attribute, value) { objRef[`${!!value ? "set" : "remove"}Attribute`](attribute, value); } class HTMLCodeComponent extends HTMLElement { constructor() { super(); const host = this.attachShadow({ mode: "closed" }); setObjPrivate(this, "host", host); host.appendChild(template.content.cloneNode(true)); const editInElement = host.querySelector(".edit-in"); editInElement .addEventListener("input", _ => { const isBR = node => { return (node.nodeType === 1) && (node.tagName.toUpperCase() === "BR"); }; editInElement.childNodes .forEach(node => { if(!node.nextSibling || !isBR(node) || !isBR(node.nextSibling)) return; editInElement.removeChild(node); }); _applyFormatHandler(this); }); host.querySelector(".edit-in") .addEventListener("blur", _ => this.dispatchEvent(new Event("change"))); document .addEventListener("copy", e => { let copyedText = (document.selection && document.selection.type != "Control") ? document.selection.createRange().text : (window.getSelection ?? (_ => ""))().toString(); copyedText = copyedText .replace(/\u2003/g, " "); navigator.clipboard.writeText(copyedText); }); host.querySelector(".edit-in") .addEventListener("keydown", e => { let appendix; switch(e.keyCode) { case 9: appendix = createTab("\u2003"); break; case 13: appendix = "<br>\n\u200b"; break; case 32: appendix = "\u2003"; break; } if(!appendix) { return; } e.preventDefault(); document.execCommand("insertHTML", false, appendix); }); host.querySelector(".edit-in") .addEventListener("paste", e => { e.preventDefault(); const pastedText = (window.clipboardData && window.clipboardData.getData) ? window.clipboardData.getData("Text") : e.clipboardData.getData("text/plain"); if(!pastedText) return; document.execCommand("insertHTML", false, pastedText .replace(/\n/g, "<br>\n")); }); host.querySelector(".edit") .addEventListener("click", e => { if(e.target.className !== "edit") { return; } host.querySelector(".edit-in").focus(); }); host.querySelector(".copy") .addEventListener("click", _ => _applyCopyHandler(this)); } connectedCallback() { !(navigator.clipboard || {}).writeText && _deleteRequiredCssRule(this, 0); if(customConfig["no-overflow"]) { _deleteRequiredCssRule(this, 1); _deleteRequiredCssRule(this, 2); } setTimeout(_ => { const lines = this.textContent .replace(/^([\t ]*\n)*/, "") .replace(/(\n[\t ]*)*$/, "") .split(/\n/g); const minIndent = lines .filter(line => (line.trim().length > 0)) .map(line => line.match(/^[\t ]*/)[0].length) .reduce((prev, cur) => Math.min(prev, cur), Infinity); const host = getObjPrivate(this, "host"); host.querySelector(".edit-in").innerHTML = lines .map(line => { if(line.trim().length === 0) { return line.trim(); } return line .replace(/\t/g, createTab(" ")) .replace(new RegExp(`^ {${minIndent}}`, "g"), "") .replace(/^ /g, "\u2003") .replace(/ {2}/g, "\u2003\u2003") .replace(/</g, "&lt;") .replace(/>/g, "&gt;"); }) .join("<br>\n"); _applyFormatHandler(this); ![undefined, null].includes(this.typeLive) && _applyLiveTyping(this); setObjPrivate(this, "initialized", true); }, 0); } attributeChangedCallback(attrName) { switch(attrName) { case "highlight": _applyHighlighting(this); return; case "language": _applyFormatHandler(this); return; case "type-live": _applyLiveTyping(this); return; } } get editable() { return _getBinaryAttribute(this, "editable"); } set editable(value) { this.setAttribute("editable", value); } get copyable() { return _getBinaryAttribute(this, "copyable"); } set copyable(value) { this.setAttribute("copyable", value); } get highlight() { return this.getAttribute("highlight"); } set highlight(value) { _setAttribute(this, "highlight", value); } get typeLive() { return this.getAttribute( "type-live"); } set typeLive(value) { this.setAttribute("type-live", value); } get language() { return this.getAttribute("language"); } set language(value) { this.setAttribute("language", value); } get innerHTML() { return !getObjPrivate(this, "initialized") ? super.innerHTML : _readBareContent(this, true); } set innerHTML(input) { _applyFormatHandler(this, input); } get textContent() { return this.innerHTML; } set textContent(input) { this.innerHTML = input; } } HTMLCodeComponent.config = function(customConfigObj) { customConfig = { ...customConfig, ...customConfigObj }; Array.from(document.querySelectorAll(devConfig.tagName)) .forEach(element => { devConfig.observedAttributes .filter(attr => customConfigObj[attr] != undefined) .forEach(attr => { element[attr] = customConfigObj; }); }); }; HTMLCodeComponent.appendStyle = function(cssRulesOrHref) { appendStyle(cssRulesOrHref) }; function appendStyle(cssRulesOrHref, lowerSpecificity = false) { let insertElement; if(/^(https?:\/\/)?(\.\.?\/)*([^\s{}/]*\/)*[^\s{}/]+$/i.test(cssRulesOrHref)) { insertElement = document.createElement("link"); insertElement.setAttribute("rel", "stylesheet"); insertElement.setAttribute("href", cssRulesOrHref); } else { insertElement = document.createElement("style"); insertElement.textContent = cssRulesOrHref .replace(/\s*\n+\s*/g, "") .replace(/"/g, '\\"') .trim(); } const getReferenceElement = parent => { return lowerSpecificity ? parent.querySelector("style") : parent.querySelector("style:nth-of-type(2)"); }; template.content.insertBefore(insertElement, getReferenceElement(template.content)); Array.from(document.querySelectorAll(devConfig.tagName)) .filter(element => (element instanceof HTMLCodeComponent)) .forEach(element => { const host = getObjPrivate(element, "host"); host.insertBefore(insertElement.cloneNode(true), getReferenceElement(host)); }); }; HTMLCodeComponent.setFormatHandler = function(languageName, handler) { languageName = !Array.isArray(languageName) ? [ languageName ] : languageName; languageName.forEach(language => { const list = formatHandlers.get(language, handler) || []; formatHandlers.set(language, list.concat([ handler ])); }); Array.from(document.querySelectorAll(devConfig.tagName)) .filter(element => (element instanceof HTMLCodeComponent)) .filter(element => { return languageName.includes(element.getAttribute("language")) || languageName.includes(devConfig.languageWildcard); }) .forEach(element => update(element)); }; HTMLCodeComponent.setCopyHandler = function(handler) { copyHandler = handler; }; const formatHandlers = new Map(); let copyHandler; let template = document.querySelector(`template[${devConfig.templateIdentifierAttribute}]`); if(!template) { template = document.createElement("template"); template.innerHTML = ` <div class="lines"></div> <div class="edit"> <div class="edit-in" contenteditable data-nosnippet></div> <code class="edit-out"> <slot></slot> </code> </div> <span class="copy">Copy</span> <!-- Â© t-ski@GitHub --> `.trim(); } window.customElements.define(devConfig.tagName, HTMLCodeComponent); appendStyle(":host([copyable]) .copy {display: block;}.edit {overflow: scroll;}.edit-in, .edit-out {white-space: nowrap !important;}:host([hidden]) {display: none !important;}:host([editable]:not([type-live])) .edit-in {display: block !important;}:host([copyable]) .copy {display: block !important;}.copy {display: none !important;}:host {--line-height: 1.75em;}:host {position: relative;display: flex;flex-direction: row;overflow: scroll;}:host([editable]:not([type-live])) .edit {cursor: text;}:host([editable]:not([type-live])) .edit-out {position: absolute;top: 0;width: 100%;height: 100%;pointer-events: none;}.edit {position: relative;flex: 1 0 0;}.lines, .edit-in, .edit-out {padding: 0.65em 0.85em;font-family: monospace;box-sizing: border-box;}.lines, .edit-in, .edit-in > div, .edit-out > div {line-height: var(--line-height);}.edit {scroll-padding-right: 0.85rem;}.lines {text-align: right;user-select: none;}.edit-in > div, .edit-out > div {height: auto;min-height: var(--line-height);}.edit-in {display: none;min-height: fit-content;color: transparent;caret-color: slategray;}.edit-in:focus {outline: none;}.edit-out {position: relative;display: block;width: fit-content;min-width: 100%;}", true); return HTMLCodeComponent; })(); HTMLCodeComponent.appendStyle(":host {background-color: #FFFFFF;color: #111111;border: 1px solid #EAEAEA;border-radius: 0.35em;}:host(:hover) .copy {opacity: 1;}.lines, .edit {height: fit-content;min-height: 100%;}.lines {background-color: #FAFAFA;color: #7A7A7A;user-select: none;}.highlighted {background-color: #FFFFDA;}.copy {position: absolute;top: 0;right: 0;cursor: pointer;margin: 0.25em;padding: 0.75em;background-color: inherit;color: #7A7A7A;text-transform: uppercase;opacity: 0;user-select: none;transition: all 200ms;}@media (prefers-color-scheme: dark) {:host {background-color: #222222;color: #FFFFFF;border-color: #6E6E6E;}.lines {background-color: #3E3E3E;}.highlighted {background-color: #444800;}}"); let copyTimeout; HTMLCodeComponent.setCopyHandler(copyButton => { copyButton.textContent = "Copied"; clearTimeout(copyTimeout); copyTimeout = setTimeout(_ => { copyButton.textContent = "Copy"; }, 2000); }); })();